"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from dateno import errors, models, utils
from dateno._hooks import HookContext
from dateno.types import OptionalNullable, UNSET
from dateno.utils.unmarshal_json_response import unmarshal_json_response
from enum import Enum
from typing import AsyncIterator, Dict, Iterator, Mapping, Optional, Union

ErrorData = Union[errors.ErrorResponseData, errors.HTTPValidationErrorData]


class ExportTimeseriesFileAcceptEnum(str, Enum):
    APPLICATION_JSON = "application/json"
    TEXT_CSV = "text/csv"
    APPLICATION_OCTET_STREAM = "application/octet-stream"
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_SHEET = (
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )


class StatisticsAPI(BaseSDK):
    def list_namespaces(
        self,
        *,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PageNamespace:
        r"""List Namespaces / Databases

        Return list of available namespaces / databases.

        :param start: Pagination offset (0-based).
        :param limit: Maximum number of items to return.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.

        Example:
            page = sdk.statistics_api.list_namespaces(limit=10)
            for ns in page.items or []:
                print(ns.id, ns.name)
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListNamespacesRequest(
            start=start,
            limit=limit,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/statsdb/0.1/ns",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_namespaces",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PageNamespace, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def list_namespaces_async(
        self,
        *,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PageNamespace:
        r"""List Namespaces / Databases

        Return list of available namespaces / databases.

        :param start: Pagination offset (0-based).
        :param limit: Maximum number of items to return.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.

        Example:
            page = await sdk.statistics_api.list_namespaces_async(limit=10)
            for ns in page.items or []:
                print(ns.id, ns.name)
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListNamespacesRequest(
            start=start,
            limit=limit,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/statsdb/0.1/ns",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_namespaces",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PageNamespace, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def iter_list_namespaces(
        self,
        *,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Iterator[models.PageNamespace]:
        """Iterate over pages of namespaces."""
        page_limit = 100 if limit is None else limit
        if page_limit <= 0:
            raise ValueError("limit must be a positive integer for pagination")

        current_start = 0 if start is None else start

        while True:
            page = self.list_namespaces(
                start=current_start,
                limit=page_limit,
                apikey=apikey,
                retries=retries,
                server_url=server_url,
                timeout_ms=timeout_ms,
                http_headers=http_headers,
            )

            items = getattr(page, "items", None) or []
            if not items:
                break

            yield page
            current_start += page_limit

    async def iter_list_namespaces_async(
        self,
        *,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> AsyncIterator[models.PageNamespace]:
        """Iterate over pages of namespaces (async)."""
        page_limit = 100 if limit is None else limit
        if page_limit <= 0:
            raise ValueError("limit must be a positive integer for pagination")

        current_start = 0 if start is None else start

        while True:
            page = await self.list_namespaces_async(
                start=current_start,
                limit=page_limit,
                apikey=apikey,
                retries=retries,
                server_url=server_url,
                timeout_ms=timeout_ms,
                http_headers=http_headers,
            )

            items = getattr(page, "items", None) or []
            if not items:
                break

            yield page
            current_start += page_limit

    def paginate_list_namespaces(
        self,
        *,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Iterator[models.Namespace]:
        """Iterate over individual namespaces."""
        for page in self.iter_list_namespaces(
            start=start,
            limit=limit,
            apikey=apikey,
            retries=retries,
            server_url=server_url,
            timeout_ms=timeout_ms,
            http_headers=http_headers,
        ):
            for item in page.items or []:
                yield item

    async def paginate_list_namespaces_async(
        self,
        *,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> AsyncIterator[models.Namespace]:
        """Iterate over individual namespaces (async)."""
        async for page in self.iter_list_namespaces_async(
            start=start,
            limit=limit,
            apikey=apikey,
            retries=retries,
            server_url=server_url,
            timeout_ms=timeout_ms,
            http_headers=http_headers,
        ):
            for item in page.items or []:
                yield item

    def get_namespace(
        self,
        *,
        ns_id: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Namespace:
        r"""Get Namespace / Database Metadata

        Return namespace / database metadata (tables list).

        :param ns_id: Namespace identifier (database key).
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.

        Example:
            ts = sdk.statistics_api.get_timeseries(ns_id="wb", ts_id="TS_ID")
            print(ts.id, ts.name)
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetNamespaceRequest(
            ns_id=ns_id,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_namespace",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Namespace, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def get_namespace_async(
        self,
        *,
        ns_id: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Namespace:
        r"""Get Namespace / Database Metadata

        Return namespace / database metadata (tables list).

        :param ns_id: Namespace identifier (database key).
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.

        Example:
            ts = await sdk.statistics_api.get_timeseries_async(
                ns_id="wb", ts_id="TS_ID"
            )
            print(ts.id, ts.name)
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetNamespaceRequest(
            ns_id=ns_id,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_namespace",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Namespace, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def list_namespace_tables(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PageTableListItem:
        r"""List Tables

        Return list of available tables by namespace.

        :param ns_id: Namespace identifier (database key).
        :param start: Start offset for pagination.
        :param limit: Maximum number of items to return.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListNamespaceTablesRequest(
            ns_id=ns_id,
            start=start,
            limit=limit,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/tables",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_namespace_tables",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PageTableListItem, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def list_namespace_tables_async(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PageTableListItem:
        r"""List Tables

        Return list of available tables by namespace.

        :param ns_id: Namespace identifier (database key).
        :param start: Start offset for pagination.
        :param limit: Maximum number of items to return.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListNamespaceTablesRequest(
            ns_id=ns_id,
            start=start,
            limit=limit,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/tables",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_namespace_tables",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PageTableListItem, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def get_namespace_table(
        self,
        *,
        ns_id: str,
        table_id: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TableWithSchema:
        r"""Get Table Metadata

        :param ns_id: Namespace identifier (database key).
        :param table_id: Table identifier within the namespace.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetNamespaceTableRequest(
            ns_id=ns_id,
            table_id=table_id,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/tables/{table_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_namespace_table",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.TableWithSchema, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def get_namespace_table_async(
        self,
        *,
        ns_id: str,
        table_id: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TableWithSchema:
        r"""Get Table Metadata

        :param ns_id: Namespace identifier (database key).
        :param table_id: Table identifier within the namespace.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetNamespaceTableRequest(
            ns_id=ns_id,
            table_id=table_id,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/tables/{table_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_namespace_table",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.TableWithSchema, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def list_indicators(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PageIndicator:
        r"""List Indicators

        Return list of indicators metadata.

        :param ns_id: Namespace identifier (database key).
        :param start: Start offset (0-based).
        :param limit: Maximum number of items to return.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListIndicatorsRequest(
            ns_id=ns_id,
            start=start,
            limit=limit,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/indicators",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_indicators",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PageIndicator, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def list_indicators_async(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PageIndicator:
        r"""List Indicators

        Return list of indicators metadata.

        :param ns_id: Namespace identifier (database key).
        :param start: Start offset (0-based).
        :param limit: Maximum number of items to return.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListIndicatorsRequest(
            ns_id=ns_id,
            start=start,
            limit=limit,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/indicators",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_indicators",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PageIndicator, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def iter_list_indicators(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Iterator[models.PageIndicator]:
        """Iterate over pages of indicators for a namespace."""
        page_limit = 100 if limit is None else limit
        if page_limit <= 0:
            raise ValueError("limit must be a positive integer for pagination")

        current_start = 0 if start is None else start

        while True:
            page = self.list_indicators(
                ns_id=ns_id,
                start=current_start,
                limit=page_limit,
                apikey=apikey,
                retries=retries,
                server_url=server_url,
                timeout_ms=timeout_ms,
                http_headers=http_headers,
            )

            items = getattr(page, "items", None) or []
            if not items:
                break

            yield page
            current_start += page_limit

    async def iter_list_indicators_async(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> AsyncIterator[models.PageIndicator]:
        """Iterate over pages of indicators for a namespace (async)."""
        page_limit = 100 if limit is None else limit
        if page_limit <= 0:
            raise ValueError("limit must be a positive integer for pagination")

        current_start = 0 if start is None else start

        while True:
            page = await self.list_indicators_async(
                ns_id=ns_id,
                start=current_start,
                limit=page_limit,
                apikey=apikey,
                retries=retries,
                server_url=server_url,
                timeout_ms=timeout_ms,
                http_headers=http_headers,
            )

            items = getattr(page, "items", None) or []
            if not items:
                break

            yield page
            current_start += page_limit

    def paginate_list_indicators(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Iterator[models.Indicator]:
        """Iterate over individual indicators for a namespace."""
        for page in self.iter_list_indicators(
            ns_id=ns_id,
            start=start,
            limit=limit,
            apikey=apikey,
            retries=retries,
            server_url=server_url,
            timeout_ms=timeout_ms,
            http_headers=http_headers,
        ):
            for item in page.items or []:
                yield item

    async def paginate_list_indicators_async(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> AsyncIterator[models.Indicator]:
        """Iterate over individual indicators for a namespace (async)."""
        async for page in self.iter_list_indicators_async(
            ns_id=ns_id,
            start=start,
            limit=limit,
            apikey=apikey,
            retries=retries,
            server_url=server_url,
            timeout_ms=timeout_ms,
            http_headers=http_headers,
        ):
            for item in page.items or []:
                yield item

    def list_timeseries(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PageTimeseries:
        r"""List Timeseries

        Return list of timeseries metadata.

        :param ns_id: Namespace identifier (database key).
        :param start: Start offset (0-based).
        :param limit: Maximum number of items to return.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListTimeseriesRequest(
            ns_id=ns_id,
            start=start,
            limit=limit,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/ts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_timeseries",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PageTimeseries, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def list_timeseries_async(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PageTimeseries:
        r"""List Timeseries

        Return list of timeseries metadata.

        :param ns_id: Namespace identifier (database key).
        :param start: Start offset (0-based).
        :param limit: Maximum number of items to return.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListTimeseriesRequest(
            ns_id=ns_id,
            start=start,
            limit=limit,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/ts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_timeseries",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.PageTimeseries, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def iter_list_timeseries(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Iterator[models.PageTimeseries]:
        """Iterate over pages of timeseries for a namespace."""
        page_limit = 100 if limit is None else limit
        if page_limit <= 0:
            raise ValueError("limit must be a positive integer for pagination")

        current_start = 0 if start is None else start

        while True:
            page = self.list_timeseries(
                ns_id=ns_id,
                start=current_start,
                limit=page_limit,
                apikey=apikey,
                retries=retries,
                server_url=server_url,
                timeout_ms=timeout_ms,
                http_headers=http_headers,
            )

            items = getattr(page, "items", None) or []
            if not items:
                break

            yield page
            current_start += page_limit

    async def iter_list_timeseries_async(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> AsyncIterator[models.PageTimeseries]:
        """Iterate over pages of timeseries for a namespace (async)."""
        page_limit = 100 if limit is None else limit
        if page_limit <= 0:
            raise ValueError("limit must be a positive integer for pagination")

        current_start = 0 if start is None else start

        while True:
            page = await self.list_timeseries_async(
                ns_id=ns_id,
                start=current_start,
                limit=page_limit,
                apikey=apikey,
                retries=retries,
                server_url=server_url,
                timeout_ms=timeout_ms,
                http_headers=http_headers,
            )

            items = getattr(page, "items", None) or []
            if not items:
                break

            yield page
            current_start += page_limit

    def paginate_list_timeseries(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Iterator[models.Timeseries]:
        """Iterate over individual timeseries for a namespace."""
        for page in self.iter_list_timeseries(
            ns_id=ns_id,
            start=start,
            limit=limit,
            apikey=apikey,
            retries=retries,
            server_url=server_url,
            timeout_ms=timeout_ms,
            http_headers=http_headers,
        ):
            for item in page.items or []:
                yield item

    async def paginate_list_timeseries_async(
        self,
        *,
        ns_id: str,
        start: Optional[int] = 0,
        limit: Optional[int] = 100,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> AsyncIterator[models.Timeseries]:
        """Iterate over individual timeseries for a namespace (async)."""
        async for page in self.iter_list_timeseries_async(
            ns_id=ns_id,
            start=start,
            limit=limit,
            apikey=apikey,
            retries=retries,
            server_url=server_url,
            timeout_ms=timeout_ms,
            http_headers=http_headers,
        ):
            for item in page.items or []:
                yield item

    def get_namespace_indicator(
        self,
        *,
        ns_id: str,
        ind_id: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Indicator:
        r"""Get Indicator Metadata

        Return indicator metadata (with optional metadata fields).

        :param ns_id: Namespace identifier (database key).
        :param ind_id: Indicator identifier to retrieve.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetNamespaceIndicatorRequest(
            ns_id=ns_id,
            ind_id=ind_id,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/indicators/{ind_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_namespace_indicator",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Indicator, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def get_namespace_indicator_async(
        self,
        *,
        ns_id: str,
        ind_id: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Indicator:
        r"""Get Indicator Metadata

        Return indicator metadata (with optional metadata fields).

        :param ns_id: Namespace identifier (database key).
        :param ind_id: Indicator identifier to retrieve.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetNamespaceIndicatorRequest(
            ns_id=ns_id,
            ind_id=ind_id,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/indicators/{ind_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_namespace_indicator",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Indicator, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def get_timeseries(
        self,
        *,
        ns_id: str,
        ts_id: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TimeseriesWithSchema:
        r"""Get Timeseries Record Metadata

        :param ns_id: Namespace identifier (database key)
        :param ts_id: Timeseries identifier to retrieve
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetTimeseriesRequest(
            ns_id=ns_id,
            ts_id=ts_id,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/ts/{ts_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_timeseries",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.TimeseriesWithSchema, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def get_timeseries_async(
        self,
        *,
        ns_id: str,
        ts_id: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TimeseriesWithSchema:
        r"""Get Timeseries Record Metadata

        :param ns_id: Namespace identifier (database key)
        :param ts_id: Timeseries identifier to retrieve
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetTimeseriesRequest(
            ns_id=ns_id,
            ts_id=ts_id,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/ts/{ts_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_timeseries",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.TimeseriesWithSchema, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def list_export_formats(
        self,
        *,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Dict[str, str]:
        r"""List Exportable Formats

        List exportable formats that could be used to export timeseries.

        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListExportFormatsRequest(
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/statsdb/0.1/list_exportable_formats",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_export_formats",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Dict[str, str], http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def list_export_formats_async(
        self,
        *,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Dict[str, str]:
        r"""List Exportable Formats

        List exportable formats that could be used to export timeseries.

        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListExportFormatsRequest(
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/statsdb/0.1/list_exportable_formats",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_export_formats",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Dict[str, str], http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def export_timeseries_file(
        self,
        *,
        ns_id: str,
        ts_id: str,
        fileext: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ExportTimeseriesFileAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ExportTimeseriesFileResponse:
        r"""Export Timeseries Data

        Export data as file.

        :param ns_id:
        :param ts_id: Timeseries identifier to retrieve
        :param fileext: Data export extension (e.g. csv, xlsx, json). Unsupported values return 400.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ExportTimeseriesFileRequest(
            ns_id=ns_id,
            ts_id=ts_id,
            fileext=fileext,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/ts/{ts_id}/export.{fileext}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/json;q=1, text/csv;q=0.8, application/octet-stream;q=0.5, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="export_timeseries_file",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/octet-stream"):
            return models.ExportTimeseriesFileResponse(
                result=http_res, headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(http_res, "200", "text/csv"):
            return models.ExportTimeseriesFileResponse(
                result=http_res, headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res,
            "200",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        ):
            return models.ExportTimeseriesFileResponse(
                result=http_res, headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(http_res, "200", "application/json"):
            return models.ExportTimeseriesFileResponse(
                result=http_res, headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            http_res_text = utils.stream_to_text_limit(http_res)
            response_data = unmarshal_json_response(
                errors.ErrorResponseData, http_res, http_res_text
            )
            raise errors.ErrorResponse(response_data, http_res, http_res_text)
        if utils.match_response(http_res, "422", "application/json"):
            http_res_text = utils.stream_to_text_limit(http_res)
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res, http_res_text
            )
            raise errors.HTTPValidationError(response_data, http_res, http_res_text)
        if utils.match_response(http_res, "500", "application/json"):
            http_res_text = utils.stream_to_text_limit(http_res)
            response_data = unmarshal_json_response(
                errors.ErrorResponseData, http_res, http_res_text
            )
            raise errors.ErrorResponse(response_data, http_res, http_res_text)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text_limit(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text_limit(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text_limit(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def export_timeseries_file_async(
        self,
        *,
        ns_id: str,
        ts_id: str,
        fileext: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ExportTimeseriesFileAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ExportTimeseriesFileResponse:
        r"""Export Timeseries Data

        Export data as file.

        :param ns_id:
        :param ts_id: Timeseries identifier to retrieve
        :param fileext: Data export extension (e.g. csv, xlsx, json). Unsupported values return 400.
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ExportTimeseriesFileRequest(
            ns_id=ns_id,
            ts_id=ts_id,
            fileext=fileext,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/statsdb/0.1/ns/{ns_id}/ts/{ts_id}/export.{fileext}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/json;q=1, text/csv;q=0.8, application/octet-stream;q=0.5, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="export_timeseries_file",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/octet-stream"):
            return models.ExportTimeseriesFileResponse(
                result=http_res, headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(http_res, "200", "text/csv"):
            return models.ExportTimeseriesFileResponse(
                result=http_res, headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res,
            "200",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        ):
            return models.ExportTimeseriesFileResponse(
                result=http_res, headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(http_res, "200", "application/json"):
            return models.ExportTimeseriesFileResponse(
                result=http_res, headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            http_res_text = await utils.stream_to_text_async_limit(http_res)
            response_data = unmarshal_json_response(
                errors.ErrorResponseData, http_res, http_res_text
            )
            raise errors.ErrorResponse(response_data, http_res, http_res_text)
        if utils.match_response(http_res, "422", "application/json"):
            http_res_text = await utils.stream_to_text_async_limit(http_res)
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res, http_res_text
            )
            raise errors.HTTPValidationError(response_data, http_res, http_res_text)
        if utils.match_response(http_res, "500", "application/json"):
            http_res_text = await utils.stream_to_text_async_limit(http_res)
            response_data = unmarshal_json_response(
                errors.ErrorResponseData, http_res, http_res_text
            )
            raise errors.ErrorResponse(response_data, http_res, http_res_text)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async_limit(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async_limit(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async_limit(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )
