"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from . import errors, models, utils
from ._hooks import HookContext
from .types import OptionalNullable, UNSET
from .utils.unmarshal_json_response import unmarshal_json_response
from typing import AsyncIterator, Iterator, List, Mapping, Optional, Union

ErrorData = Union[errors.ErrorResponseData, errors.HTTPValidationErrorData]


class DataCatalogsAPI(BaseSDK):
    r"""Endpoints for fetching data from Dateno registry of data catalogs.
    https://dateno.io/registry - Dateno catalog registry
    """

    def get_catalog_by_id(
        self,
        *,
        catalog_id: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataCatalog:
        r"""Get Data Catalog Record

        This endpoint fetches a single item from the data catalog registry using its unique ID (UID). The full record will be returned. If the catalog has been merged into another catalog canonical entity,
        the request will automatically redirect to the new one.

        Check out the web version of the catalog registry: [Example catalog](https://dateno.io/registry/catalog/cdi00001616/).

        :param catalog_id: UID of the data catalog to retrieve
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.

        Example:
            catalog = sdk.data_catalogs_api.get_catalog_by_id(
                catalog_id="cdi00001616"
            )
            print(catalog.id)
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCatalogByIDRequest(
            catalog_id=catalog_id,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/registry/catalog/{catalog_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_catalog_by_id",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataCatalog, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def get_catalog_by_id_async(
        self,
        *,
        catalog_id: str,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataCatalog:
        r"""Get Data Catalog Record

        This endpoint fetches a single item from the data catalog registry using its unique ID (UID). The full record will be returned. If the catalog has been merged into another catalog canonical entity,
        the request will automatically redirect to the new one.

        Check out the web version of the catalog registry: [Example catalog](https://dateno.io/registry/catalog/cdi00001616/).

        :param catalog_id: UID of the data catalog to retrieve
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.

        Example:
            catalog = await sdk.data_catalogs_api.get_catalog_by_id_async(
                catalog_id="cdi00001616"
            )
            print(catalog.id)
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCatalogByIDRequest(
            catalog_id=catalog_id,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/registry/catalog/{catalog_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_catalog_by_id",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataCatalog, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def list_catalogs(
        self,
        *,
        q: Optional[str] = "",
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        software: Optional[str] = None,
        owner_type: Optional[str] = None,
        catalog_type: Optional[str] = None,
        owner_country: Optional[List[str]] = None,
        coverage_country: Optional[List[str]] = None,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataCatalogSearchResponse:
        r"""Search Data Catalogs

        Get a list of items from the data catalog.

        Intro: [Dateno catalog registry](https://dateno.io/registry/).

        :param q:
        :param limit: Max items per page.
        :param offset: Pagination offset (0-based).
        :param software:
        :param owner_type:
        :param catalog_type:
        :param owner_country:
        :param coverage_country:
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.

        Example:
            res = sdk.data_catalogs_api.list_catalogs(
                q="climate", limit=20, offset=0
            )
            for item in res.data or []:
                print(item.id)
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListCatalogsRequest(
            q=q,
            limit=limit,
            offset=offset,
            software=software,
            owner_type=owner_type,
            catalog_type=catalog_type,
            owner_country=owner_country,
            coverage_country=coverage_country,
            apikey=apikey,
        )

        req = self._build_request(
            method="GET",
            path="/registry/search/catalogs/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_catalogs",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataCatalogSearchResponse, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    async def list_catalogs_async(
        self,
        *,
        q: Optional[str] = "",
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        software: Optional[str] = None,
        owner_type: Optional[str] = None,
        catalog_type: Optional[str] = None,
        owner_country: Optional[List[str]] = None,
        coverage_country: Optional[List[str]] = None,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataCatalogSearchResponse:
        r"""Search Data Catalogs

        Get a list of items from the data catalog.

        Intro: [Dateno catalog registry](https://dateno.io/registry/).

        :param q:
        :param limit: Max items per page.
        :param offset: Pagination offset (0-based).
        :param software:
        :param owner_type:
        :param catalog_type:
        :param owner_country:
        :param coverage_country:
        :param apikey:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.

        Example:
            res = await sdk.data_catalogs_api.list_catalogs_async(
                q="climate", limit=20, offset=0
            )
            for item in res.data or []:
                print(item.id)
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListCatalogsRequest(
            q=q,
            limit=limit,
            offset=offset,
            software=software,
            owner_type=owner_type,
            catalog_type=catalog_type,
            owner_country=owner_country,
            coverage_country=coverage_country,
            apikey=apikey,
        )

        req = self._build_request_async(
            method="GET",
            path="/registry/search/catalogs/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="list_catalogs",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Optional[ErrorData] = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataCatalogSearchResponse, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKDefaultError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKDefaultError(
            "Unexpected response received", http_res, http_res_text
        )

    def iter_list_catalogs(
        self,
        *,
        q: Optional[str] = "",
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        software: Optional[str] = None,
        owner_type: Optional[str] = None,
        catalog_type: Optional[str] = None,
        owner_country: Optional[List[str]] = None,
        coverage_country: Optional[List[str]] = None,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Iterator[models.DataCatalogSearchResponse]:
        """Iterate over pages of catalog search results."""
        page_limit = 10 if limit is None else limit
        if page_limit <= 0:
            raise ValueError("limit must be a positive integer for pagination")

        current_offset = 0 if offset is None else offset

        while True:
            page = self.list_catalogs(
                q=q,
                limit=page_limit,
                offset=current_offset,
                software=software,
                owner_type=owner_type,
                catalog_type=catalog_type,
                owner_country=owner_country,
                coverage_country=coverage_country,
                apikey=apikey,
                retries=retries,
                server_url=server_url,
                timeout_ms=timeout_ms,
                http_headers=http_headers,
            )

            items = getattr(page, "data", None) or []
            if not items:
                break

            yield page
            current_offset += page_limit

    async def iter_list_catalogs_async(
        self,
        *,
        q: Optional[str] = "",
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        software: Optional[str] = None,
        owner_type: Optional[str] = None,
        catalog_type: Optional[str] = None,
        owner_country: Optional[List[str]] = None,
        coverage_country: Optional[List[str]] = None,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> AsyncIterator[models.DataCatalogSearchResponse]:
        """Iterate over pages of catalog search results (async)."""
        page_limit = 10 if limit is None else limit
        if page_limit <= 0:
            raise ValueError("limit must be a positive integer for pagination")

        current_offset = 0 if offset is None else offset

        while True:
            page = await self.list_catalogs_async(
                q=q,
                limit=page_limit,
                offset=current_offset,
                software=software,
                owner_type=owner_type,
                catalog_type=catalog_type,
                owner_country=owner_country,
                coverage_country=coverage_country,
                apikey=apikey,
                retries=retries,
                server_url=server_url,
                timeout_ms=timeout_ms,
                http_headers=http_headers,
            )

            items = getattr(page, "data", None) or []
            if not items:
                break

            yield page
            current_offset += page_limit

    def paginate_list_catalogs(
        self,
        *,
        q: Optional[str] = "",
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        software: Optional[str] = None,
        owner_type: Optional[str] = None,
        catalog_type: Optional[str] = None,
        owner_country: Optional[List[str]] = None,
        coverage_country: Optional[List[str]] = None,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Iterator[models.DataCatalogSearchItem]:
        """Iterate over individual catalog search items."""
        for page in self.iter_list_catalogs(
            q=q,
            limit=limit,
            offset=offset,
            software=software,
            owner_type=owner_type,
            catalog_type=catalog_type,
            owner_country=owner_country,
            coverage_country=coverage_country,
            apikey=apikey,
            retries=retries,
            server_url=server_url,
            timeout_ms=timeout_ms,
            http_headers=http_headers,
        ):
            for item in page.data or []:
                yield item

    async def paginate_list_catalogs_async(
        self,
        *,
        q: Optional[str] = "",
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        software: Optional[str] = None,
        owner_type: Optional[str] = None,
        catalog_type: Optional[str] = None,
        owner_country: Optional[List[str]] = None,
        coverage_country: Optional[List[str]] = None,
        apikey: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> AsyncIterator[models.DataCatalogSearchItem]:
        """Iterate over individual catalog search items (async)."""
        async for page in self.iter_list_catalogs_async(
            q=q,
            limit=limit,
            offset=offset,
            software=software,
            owner_type=owner_type,
            catalog_type=catalog_type,
            owner_country=owner_country,
            coverage_country=coverage_country,
            apikey=apikey,
            retries=retries,
            server_url=server_url,
            timeout_ms=timeout_ms,
            http_headers=http_headers,
        ):
            for item in page.data or []:
                yield item
