# tests/test_raw_data_access_async_unit.py
"""
Unit tests for the `RawDataAccess` client (async only).

Scope:
    These tests validate SDK *client-side* behavior for the Raw Data Access API:
      - correct request construction for async methods
      - correct branching on HTTP status codes using the SDK response matcher
      - correct unmarshal target model depending on the status code
      - correct exception type raised for error responses

Non-goals:
    - actual HTTP transport behavior (integration responsibility)
    - correctness of `dateno.utils.match_response` (patched with deterministic fake)

Notes:
    The RawDataAccess layer is generated by Speakeasy. The interesting/fragile
    parts to guard with unit tests are:
      - path templates (e.g. "/raw/0.1/entry/{entry_id}")
      - operation_id propagation via HookContext
      - which model type is passed into `unmarshal_json_response`
      - which exception is raised for error status codes
"""

from __future__ import annotations

from typing import Any

import pytest

import dateno.raw_data_access as raw_mod
from dateno import errors
from dateno.raw_data_access import RawDataAccess
from test_utils import (
    FakeResponse,
    assert_request_common,
    make_unmarshal_json_response_stub,
    mk_cfg,
    patch_match_response,
)


@pytest.fixture
def anyio_backend() -> str:
    """
    Force the AnyIO backend to asyncio.

    Speakeasy async methods work with asyncio; we intentionally do not depend on trio.
    """
    return "asyncio"


@pytest.mark.anyio
async def test_get_raw_entry_by_id_async_builds_request_and_returns_unmarshaled(
    monkeypatch,
) -> None:
    """
    Ensure `get_raw_entry_by_id_async()`:
      - builds the expected request (method/path/base_url)
      - matches the 200 JSON response branch
      - unmarshals into the expected model type (SearchIndexEntry)
      - returns the unmarshaled value

    This test is intentionally strict about the request path template, because
    path regressions are common when regenerating SDKs.
    """
    api = RawDataAccess(mk_cfg())

    captured: dict[str, Any] = {}

    def fake_build_request_async(*, method, path, base_url, request, **kwargs):
        captured["build"] = {
            "method": method,
            "path": path,
            "base_url": base_url,
            "request_type": type(request).__name__,
        }
        return object()

    async def fake_do_request_async(*, hook_ctx, request, **kwargs):
        captured["do"] = {"operation_id": getattr(hook_ctx, "operation_id", None)}
        return FakeResponse(
            200,
            headers={"Content-Type": "application/json"},
            content=b'{"ok": true}',
        )

    monkeypatch.setattr(api, "_build_request_async", fake_build_request_async)
    monkeypatch.setattr(api, "do_request_async", fake_do_request_async)

    # Deterministic matcher for predictable branching.
    patch_match_response(monkeypatch)

    # Unmarshal stub: ensure the API method requests SearchIndexEntry on the 200 branch.
    unmarshal_stub = make_unmarshal_json_response_stub(
        {
            "SearchIndexEntry": {"unmarshaled": True},
        }
    )
    monkeypatch.setattr(raw_mod, "unmarshal_json_response", unmarshal_stub)

    result = await api.get_raw_entry_by_id_async(entry_id="abc123", apikey="k")

    assert result == {"unmarshaled": True}
    assert_request_common(
        captured["build"],
        method="GET",
        path="/raw/0.1/entry/{entry_id}",
        base_url="https://example.invalid",
        request_type="GetRawEntryByIDRequest",
    )
    assert captured["do"]["operation_id"] == "get_raw_entry_by_id"


@pytest.mark.anyio
async def test_get_raw_entry_by_id_async_500_raises_error_response(monkeypatch) -> None:
    """
    Ensure `get_raw_entry_by_id_async()` raises `errors.ErrorResponse` for server errors.

    Specifically validates the 500 error branch:
      - response is matched as a 5XX
      - body is unmarshaled into `errors.ErrorResponseData`
      - SDK raises `errors.ErrorResponse` (not a generic SDKDefaultError)

    We keep this test focused on the branching and exception type rather than
    asserting the full error payload shape.
    """
    api = RawDataAccess(mk_cfg())

    monkeypatch.setattr(api, "_build_request_async", lambda **kwargs: object())

    async def fake_do_request_async(**kwargs):
        return FakeResponse(
            500,
            headers={"Content-Type": "application/json"},
            content=b'{"detail":"boom"}',
        )

    monkeypatch.setattr(api, "do_request_async", fake_do_request_async)

    patch_match_response(monkeypatch)

    # Unmarshal stub: ErrorResponseData is required for the 5XX branch.
    unmarshal_stub = make_unmarshal_json_response_stub(
        {
            errors.ErrorResponseData: {"detail": "boom"},
        }
    )
    monkeypatch.setattr(raw_mod, "unmarshal_json_response", unmarshal_stub)

    with pytest.raises(errors.ErrorResponse):
        await api.get_raw_entry_by_id_async(entry_id="abc123", apikey="k")
